# 第13章 拷贝控制


## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```cpp
class Foo{
public:
    Foo(); //默认构造函数
    Foo(const Foo&);//拷贝构造函数
}
```
#### 合成拷贝构造函数

#### 拷贝初始化

#### 参数和返回值

#### 拷贝初始化的限制

#### 编译器可以绕过拷贝构造函数

### 13.1.2 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```cpp
Sales_data trans,accum;
trans = accum; //使用Sales_data的拷贝赋值运算符
```

#### 重载赋值运算符

#### 合成拷贝赋值运算符

### 13.1.3 析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非`static`数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非`static`数据成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数：

```cpp
class Foo{
public:
    ~Foo();
    //...
};
```

#### 什么时候会调用析构函数

#### 合成析构函数

### 13.1.4 三/五法则

#### 需要析构函数的类也需要拷贝和赋值操作

#### 需要拷贝操作的类也需要赋值操作、反之亦然

### 13.1.5 使用=default

### 13.1.6 阻止拷贝

#### 定义删除的函数

#### 析构函数不能是删除的成员

#### 合成的拷贝控制成员可能是删除的

#### private拷贝控制

## 13.2 拷贝控制和资源管理

### 13.2.1 行为像值的类

#### 类值拷贝赋值运算符

### 13.2.2 定义行为像指针的类

## 13.3 交换操作

#### 编写我们自己的swap函数

#### swap函数应该调用swap，而不是std::swap

#### 在赋值运算符中使用swap

## 13.4 拷贝控制实例

## 13.5 动态内存管理类

## 13.6 对象移动

### 13.6.1 右值引用

### 13.6.2 移动构造函数和移动赋值运算符

### 13.6.3 右值引用和成员函数

